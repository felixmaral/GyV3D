<!DOCTYPE html>

<html>

  <head>

    <title>Breakout Game</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

  </head>

  <style>

		body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 20px;
            color: rgb(255, 255, 255);
            background: linear-gradient(165deg, rgba(2,0,36,1) 0%, rgba(9,9,121,0.9136029411764706) 49%, rgb(17, 0, 255) 100%);
            background-repeat: no-repeat;
			margin: 0;
			padding: 0;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		canvas {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

        #container {
            margin: 20px;
            text-align: center;
        }

        #gamestatus {
            font-size: 40px;
            text-align: center;
        }

        #gamestatus, #container {
            z-index: 9999;
            
        }

  </style>

  <body onload="init()">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- Carga la libreria Threejs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script> <!-- Carga la libreria para utilizar controles -->
    

    <div id="gamestatus"></div>

    <div id="container">

        <div>Lifes: <span id="lifes">3</span></div>
        <div>Points: <span id="points">0</span></div>

    </div>

    <script>

        /* Crear escena */
        var scene = new THREE.Scene();

        /* Dar dimensiones a la escena */
        var sceneWidth = window.innerWidth - 300;
        var sceneHeight = window.innerHeight - 300;

        /* Crear cámara, posición y lookAt */
        var camera = new THREE.PerspectiveCamera(90, sceneWidth / sceneHeight, 0.02, 100);
        camera.position.set(0, -10, 20);
        camera.lookAt(scene.position);

        /* Crear renderizador con antialias activado, y dandole dimensiones y sombras activadas */
        var renderer = new THREE.WebGLRenderer({
            antialias : true
        });
        renderer.shadowMap.enabled = true;
        renderer.setSize(sceneWidth, sceneHeight);
        document.body.appendChild(renderer.domElement);

        /* Función que renderiza la escena */
        var render = function() {
            renderer.render(scene, camera);
        };

        /* Función que crea y añade luz a la escena, ambiental y direccional */
        function addLight(scene) {
            lightDirectional = new THREE.SpotLight(0xffffff, 0.35);;
            lightDirectional.position.set(5, 20, 25);
            lightDirectional.castShadow = true;
            lightDirectional.shadow.camera.near = 1;
            lightDirectional.shadow.camera.far = 50;
            lightDirectional.shadow.camera.left = -30;
            lightDirectional.shadow.camera.right = 30;
            lightDirectional.shadow.camera.top = 30;
            lightDirectional.shadow.camera.bottom = -30;
            lightDirectional.shadow.mapSize.width = 4096;
            lightDirectional.shadow.mapSize.height = 4096;
            scene.add(lightDirectional);

            var light = new THREE.AmbientLight(0xFFFFFF, 0.35);
            return ([light, lightDirectional]);
        }

        /* Funcion que crea una esfera con textura de madera y la añade a la escena */
        function addSphere(scene) {
            var geometry = new THREE.SphereGeometry(0.5, 20, 20);
            var texture = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_Color.jpg", render);
            var textureD = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_Displacement.jpg", render);
            var textureR = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_Roughness.jpg", render);
            var textureN = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_NormalGL.jpg", render);
            var textureN2 = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_NormalDX.jpg", render);
            var material = new THREE.MeshPhysicalMaterial({
                roughnessMap: textureR,
                /* displacementMap: textureD, */
                normalMap: textureN,
                map: texture
            }); 
            var mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true; /* Activar que produzca sombra */
            mesh.position.z = 1;
            mesh.name = "sphere";
            return mesh;
        }

        /* Funcion que crea un plano con textura de madera y la añade a la escena */
        function addFloor(scene, render) {
            var geometry = new THREE.PlaneGeometry(25, 25);
            var texture = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Color.jpg", render);
            var textureD = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Displacement.jpg", render);
            var textureR = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Roughness.jpg", render);
            var textureN = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalGL.jpg", render);
            var textureN2 = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalDX.jpg", render);
            var material = new THREE.MeshPhysicalMaterial({
                displacementMap: textureD,
                normalMap: textureN,
                roughnessMap: textureR,
                normalMap: textureN2,
                map: texture
            });
            var mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = true; /* Activar que reciva sombra */
            mesh.name = "floor";
            return mesh;
        }

        /* Funcion que crea los bordes con texturas de madera y los añade a la escena */
        function addBorders(scene, render) {
            const geometryTop = new THREE.BoxGeometry( 26, 1, 3 );
            var texture = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Color.jpg", render);
            var textureD = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Displacement.jpg", render);
            var textureR = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Roughness.jpg", render);
            var textureN = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalGL.jpg", render);
            var textureN2 = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalDX.jpg", render);
            var material = new THREE.MeshPhysicalMaterial({
                normalMap: textureN,
                roughnessMap: textureR,
                normalMap: textureN2,
                map: texture
            });

            /* Borde de arriba */
            var mesh = new THREE.Mesh(geometryTop, material);
            mesh.receiveShadow = true; /* Activar que reciva sombra */
            mesh.castShadow = true;
            mesh.position.y = 12.5;
            mesh.position.z = 1.85;
            mesh.name = "top";

            const geometrySides = new THREE.BoxGeometry( 1, 25, 3 );
            var texture = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Color.jpg", render);
            var textureD = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Displacement.jpg", render);
            var textureR = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_Roughness.jpg", render);
            var textureN = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalGL.jpg", render);
            var textureN2 = new THREE.TextureLoader().load("texturasBlockout/Wood069_1K_NormalDX.jpg", render);
            var material = new THREE.MeshPhysicalMaterial({
                normalMap: textureN,
                roughnessMap: textureR,
                normalMap: textureN2,
                map: texture
            });

            /* Borde de la izquierda */
            var mesh1 = new THREE.Mesh(geometrySides, material);
            mesh1.receiveShadow = true; /* Activar que reciva sombra */
            mesh.castShadow = true;
            mesh1.position.x = -12.5;
            mesh1.position.z = 1.85;
            mesh1.name = "left";

            /* Borde de la derecha */
            var mesh2 = new THREE.Mesh(geometrySides, material);
            mesh2.receiveShadow = true; /* Activar que reciva sombra */
            mesh.castShadow = true;
            mesh2.position.x = 12.5;
            mesh2.position.z = 1.85;
            mesh2.name = "right"
            

            return ([mesh, mesh2, mesh1])
        }

        // Crear una base movil
        var baseGeometry = new THREE.BoxGeometry(5, 1, 2);
        var texture = new THREE.TextureLoader().load("texturasBlockout/Fabric026_1K_Color.jpg", render);
        var textureR = new THREE.TextureLoader().load("texturasBlockout/Fabric026_1K_Roughness.jpg", render);
        var textureN = new THREE.TextureLoader().load("texturasBlockout/Fabric026_1K_NormalGL.jpg", render);
        var textureN2 = new THREE.TextureLoader().load("texturasBlockout/Marble020_1K_NormalDX.jpg", render);
        var textureM = new THREE.TextureLoader().load("texturasBlockout/.jpg", render);
         // Creación del material
         var material = new THREE.MeshPhysicalMaterial({
                    map: texture,
                    roughnessMap: textureR,
                    normalMap: textureN,
                    metalnessMap: textureM,
                    clearcoatNormalMap: textureN2 // Especificar un segundo mapa normal
                });
        var base = new THREE.Mesh(baseGeometry, material);
        base.position.y = -13;
        base.position.z = 1.02;
        base.name = "base"
        scene.add(base);

        var change = new THREE.Mesh(baseGeometry, material);
        change.position.y = -30;
        change.position.z = 1.02;

        /* Crear bricks */
        function addBricks(scene, render) {
            const bricks = [];
            const separacion = 5; // distancia entre objetos

            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 4; j++) {
                const nombre = `obj${i}${j}`; // nombre del objeto
                const geometria = new THREE.BoxGeometry(4, 1, 1); // geometria del objeto
                var texture = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_Color.png", render);
                var textureD = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_Displacement.png", render);
                var textureR = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_Roughness.png", render);
                var textureN = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_NormalGL.png", render);
                var textureN2 = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_NormalDX.png", render);
                var textureM = new THREE.TextureLoader().load("texturasBlockout/metal/Metal003_1K_Metalness.png", render);
                // Creación del material
                var material = new THREE.MeshPhysicalMaterial({
                    map: texture,
                    roughnessMap: textureR,
                    normalMap: textureN,
                    metalnessMap: textureM,
                    clearcoatNormalMap: textureN2 // Especificar un segundo mapa normal
                });
                const mesh = new THREE.Mesh(geometria, material); // mesh del objeto
                mesh.name = nombre;
                mesh.position.set(i * (separacion - 0.35) - 9.3, j * (separacion - 3) + 4.8, 1.4); // posicion del objeto
                bricks.push({ nombre, mesh }); // añadir objeto al array de objetos
                }
                
            }
            return bricks;
        }

        // Agregar un controlador de eventos de teclado
        document.addEventListener('keydown', onDocumentKeyDown, false);

        function onDocumentKeyDown( event ) {
            var keyCode = event.which;
            // Mover la base a la izquierda si se presiona la tecla de flecha izquierda
            if ( keyCode == 37 && base.position.x > -9.5) {
                base.position.x -= 0.6;
            }
            // Mover la base a la derecha si se presiona la tecla de flecha derecha
            else if ( keyCode == 39 && base.position.x < 9.5) {
                base.position.x += 0.6;
            }
        }

        bricks = 0;
        count = 0;
        speedbase = 0.18;

        function checkCollision(sphere, borders) {
            var originPosition = sphere.position.clone();
            var positionBreak = 2;
            var positionHit;

            const positionAttribute = sphere.geometry.getAttribute( 'position' );
            const localVertex = new THREE.Vector3();
            const globalVertex = new THREE.Vector3();
            for ( let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex ++ ) {
                localVertex.fromBufferAttribute( positionAttribute, vertexIndex );
                globalVertex.copy( localVertex ).applyMatrix4( sphere.matrixWorld );
                var directionVector = globalVertex.sub(sphere.position);
                var ray = new THREE.Raycaster(originPosition, directionVector.clone().normalize());
                var collisionResults = ray.intersectObjects(borders);
                if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {
                    // Collision detected
                    if (collisionResults[0].object.name == "left" || collisionResults[0].object.name == "right") {
                    stepX *= -1;
                    audio.play();
                    }
                    if (collisionResults[0].object.name == "top") {
                    stepY *= -1;
                    audio.play();
                    } 

                    if (collisionResults[0].object.name == "base") {

                        if (count >= 3) {
                            pointsGame *= 2;
                            addPoints(0);
                        }

                        count = 0;

                        /* Velocidad variable */

                        positionBreak = Math.abs(positionBreak) + 50;
                        positionHit = Math.abs(base.position.x) + 50;
                        console.log(Math.abs(positionHit - positionBreak))
                        speed = Math.abs(positionHit - positionBreak) * 0.01 + speedbase;

                        // Calcular la posición relativa de la colisión
                        var collisionPoint = collisionResults[0].point;
                        var relativeCollisionPoint = collisionPoint.clone().sub(base.position);
                        console.log(relativeCollisionPoint)

                        // Obtener el valor absoluto de la posición relativa en x de la colisión
                        var relativeCollisionX = relativeCollisionPoint.x;

                        // Calcular el ángulo de rebote en base a la posición de la colisión
                        var angle = Math.atan2(relativeCollisionPoint.y, relativeCollisionPoint.x);

                        // Calcular el nuevo ángulo de rebote
                        var reflectionAngle =  Math.abs(angle) - Math.PI;

                        if (stepX == 0) {
                                if (relativeCollisionPoint.x < 0) {
                                stepX = Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            } else {
                                stepX = Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            }
                        } else if (stepX < 0) {
                                if (relativeCollisionPoint.x < 0) {
                                stepX = -Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            } else {
                                stepX = Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            } 
                        } else {
                                if (relativeCollisionPoint.x < 0) {
                                stepX = Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            } else {
                                stepX = -Math.cos(reflectionAngle) * speed;
                                stepY = -Math.sin(reflectionAngle) * speed;
                            }
                        }

                        audio.play();
                    }

                    if (collisionResults[0].object.name == "obj00") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(4,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj01") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(5,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj02") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(6,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj03") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(7,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj10") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(8,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj11") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(9,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj12") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(10,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj13") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(11,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj20") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(12,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj21") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(13,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj22") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(14,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj23") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(15,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj30") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(16,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj31") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(17,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj32") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(18,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj33") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(19,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj40") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(20,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj41") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(2);
                    borders.splice(21,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj42") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(22,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    if (collisionResults[0].object.name == "obj43") {
                        var collisionPoint = collisionResults[0].point;
                        if(collisionPoint.x < sphere.position.x || collisionPoint.x > sphere.position.x) {
                            stepX *= -1
                        } else {
                            stepY *= -1;
                        }
                    scene.remove(collisionResults[0].object)
                    count = count + 1;
                    bricks = bricks + 1;
                    console.log(count, bricks)
                    addPoints(1);
                    borders.splice(23,1,change)
                    positionBreak = base.position.x;
                    audio.play();
                    } 
                    break;
                }

                if (sphere.position.y <= -13) {

                    if (lifesGame >= 1 ) {
                        lifesGame -= 1;
                    game.lifes.innerHTML = lifesGame;

                    console.log(lifesGame)
                    }

                    if (lifesGame == 0) {
                        
                        document.getElementById("gamestatus").innerHTML = " GAME OVER "

                        stepX *= 0;
                        stepY *= 0;

                        scene.remove(sphere);

                    } else if (lifesGame > 0) {

                        /* Resetear a posición inicial */
                        sphere.position.x = 0;
                        sphere.position.y = 0;
                        sphere.position.z = 1;

                        /* Movimiento inicial */
                        stepX = (Math.random() - 0.5) * 0.18;
                        stepY = -0.18;

                    }
                }

                if (bricks == 20) {

                    document.getElementById("gamestatus").innerHTML = " ¡YOU WIN! "

                    stepX *= 0;
                    stepY *= 0;
                }
            }
        }

        lifesGame = 3;
        pointsGame = 0;

        /* Atributos del juego */
        game = {
            points: document.getElementById("points"),
            lifes: document.getElementById("lifes")
        }

        function pause(event) {
            if (event.key === "Escape" || event.key === "Esc") { // Comprueba si se presionó la tecla "Escape"
                saveStepX = stepX;
                saveStepY = stepY;
                document.getElementById("gamestatus").innerHTML = "PAUSE"
                stepX = 0;
                stepY = 0;
            }
        }

        function play(event) {
            if (event.key === "Enter") {
                stepX = saveStepX;
                stepY = saveStepY;
                document.getElementById("gamestatus").innerHTML = ""
            }
        }

        resetButton = document.getElementById("reset");

        function reset() {
            // Añadir los objetos a la escena
            bricks.forEach(brick => {
                scene.add(brick.mesh);
                bricksMesh.push(brick.mesh)
            });

            console.log(bricksMesh)


            borders = [ left, right, top, base ];

            bricksMesh.forEach(brick => {
                borders.push(brick)
            });

            render();




            pointsGame = 0;
            lifesGame = 3;

            game.points.innerHTML = pointsGame;
            game.lifes.innerHTML = lifesGame;

            stepX = (Math.random() - 0.5) * 0.18
            stepY = -0.18
        }

        

        function addPoints(points) {
            sum = pointsGame += points
            game.points.innerHTML = sum;
        }

        function animate(sphere, borders, renderer, scene, camera) {
            checkCollision(sphere, borders);
            
            sphere.position.x += stepX;
            sphere.position.y += stepY;

            renderer.render(scene, camera);

            renderer.setAnimationLoop( function() {
                animate(sphere, borders, renderer, scene, camera);
            });
        }

        // Carga el archivo de sonido utilizando THREE.AudioLoader()
        const loader = new THREE.AudioLoader();
        let audioBuffer;

        loader.load(
            'texturasBlockout/Toc.wav',
            buffer => {
                audioBuffer = buffer;
            },
            xhr => console.log(`${(xhr.loaded / xhr.total) * 100}% cargado`),
            error => console.error('Error de carga', error)
        );

        const listener = new THREE.AudioListener();

        // Crea un objeto THREE.PositionalAudio para representar el sonido
        const audio = new THREE.PositionalAudio(listener);
        audio.setBuffer(audioBuffer);

        // Añade el objeto THREE.PositionalAudio a la escena como un hijo del objeto que va a colisionar
        scene.add(audio);

        var stepX = (Math.random() - 0.5) * 0.18
        var stepY = -0.15;  
    
        /* Funcion de inicio */
        function init() {

            var light = addLight(scene)[0];
            var DirectionalLight = addLight(scene)[1];
            var sphere = addSphere(scene);
            var top = addBorders(scene, render)[0];
            var left = addBorders(scene, render)[2];
            var right = addBorders(scene, render)[1];
            var floor = addFloor(scene, render);
            var bricks = addBricks(scene, render);

            console.log(sphere.position)
            
            scene.add(light);
            scene.add(base);
            scene.add(DirectionalLight);
            scene.add(top);
            scene.add(left);
            scene.add(right);
            scene.add(floor);
            scene.add(sphere);

            bricksMesh = [];

            // Añadir los objetos a la escena
            bricks.forEach(brick => {
                scene.add(brick.mesh);
                bricksMesh.push(brick.mesh)
            });

            console.log(bricksMesh)


            var borders = [ left, right, top, base ];

            bricksMesh.forEach(brick => {
                borders.push(brick)
            });

            console.log(borders)

            render();
            
            // Control de camara 
            var control = new function() {
                this.fov = camera.fov;
                this.Cx = camera.position.x;
                this.Cy = camera.position.y;
                this.Cz = camera.position.z;
                this.Lx = lightDirectional.position.x;
                this.Ly = lightDirectional.position.y;
                this.Lz = lightDirectional.position.z;
                this.Level = speedbase;


                this.update = function() {
                    camera.fov = control.fov;
                    camera.position.x = control.Cx;
                    camera.position.y = control.Cy;
                    camera.position.z = control.Cz;
                    lightDirectional.position.x = control.Lx;
                    lightDirectional.position.y = control.Ly;
                    lightDirectional.position.z = control.Lz;
                    camera.lookAt(scene.position);
    
                    camera.updateProjectionMatrix();

                    speedbase = control.Level * 0.2 + 0.2;
                }
            };

            var gui = new dat.GUI();
            gui.add(control, 'fov', 0, 180).onChange(control.update);
            gui.add(control, 'Cx', -30, 30).onChange(control.update);
            gui.add(control, 'Cy', -30, 30).onChange(control.update);
            gui.add(control, 'Cz', -30, 30).onChange(control.update);
            gui.add(control, 'Lx', -30, 30).onChange(control.update);
            gui.add(control, 'Ly', -30, 30).onChange(control.update);
            gui.add(control, 'Lz', -30, 30).onChange(control.update);
            gui.add(control, 'Level', 0, 2).onChange(control.update);

            animate(sphere, borders, renderer, scene, camera);
            document.addEventListener('keydown', pause, false);
            document.addEventListener('keydown', play, false);

        }
        

    </script>

    <!-- <button id="reset">Reiniciar</button> -->

  </body>

</html>



